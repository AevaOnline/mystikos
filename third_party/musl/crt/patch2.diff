diff --git a/Makefile b/Makefile
index bd8f5c38..fcc35f3e 100644
--- a/Makefile
+++ b/Makefile
@@ -160,12 +160,16 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
 	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+	$(MAKE) objects.mak
 
 lib/libc.a: $(AOBJS)
 	rm -f $@
 	$(AR) rc $@ $(AOBJS)
 	$(RANLIB) $@
 
+objects.mak: $(LOBJS) $(LDSO_OBJS)
+	@ echo "MUSL_OBJECTS = $(addprefix $(CURDIR)/,$(LOBJS) $(LDSO_OBJS))" > objects.mak
+
 $(EMPTY_LIBS):
 	rm -f $@
 	$(AR) rc $@
diff --git a/arch/x86_64/syscall_arch.h b/arch/x86_64/syscall_arch.h
index 92d5c179..a3e53791 100644
--- a/arch/x86_64/syscall_arch.h
+++ b/arch/x86_64/syscall_arch.h
@@ -1,64 +1,69 @@
 #define __SYSCALL_LL_E(x) (x)
 #define __SYSCALL_LL_O(x) (x)
 
+long libos_syscall(long n, long params[6]);
+
 static __inline long __syscall0(long n)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall1(long n, long a1)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall2(long n, long a1, long a2)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
-						  : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall3(long n, long a1, long a2, long a3)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall4(long n, long a1, long a2, long a3, long a4)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10): "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    return libos_syscall(n, params);
 }
 
 static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	register long r9 __asm__("r9") = a6;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    params[5] = a6;
+    return libos_syscall(n, params);
 }
 
 #define VDSO_USEFUL
diff --git a/ldso/dlstart.c b/ldso/dlstart.c
index 20d50f2c..b352874f 100644
--- a/ldso/dlstart.c
+++ b/ldso/dlstart.c
@@ -1,4 +1,5 @@
 #include <stddef.h>
+#include <errno.h>
 #include "dynlink.h"
 #include "libc.h"
 
@@ -124,7 +125,6 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 			local_cnt = dynv[i+1];
 		for (i=0; i<local_cnt; i++) got[i] += base;
 	}
-
 	rel = (void *)(base+dyn[DT_REL]);
 	rel_size = dyn[DT_RELSZ];
 	for (; rel_size; rel+=2, rel_size-=2*sizeof(size_t)) {
@@ -146,3 +146,34 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 	GETFUNCSYM(&dls2, __dls2, base+dyn[DT_PLTGOT]);
 	dls2((void *)base, sp);
 }
+
+__attribute__((__weak__))
+void libos_trace(const char* msg)
+{
+}
+
+__attribute__((__weak__))
+void libos_trace_ptr(const char* msg, const void* ptr)
+{
+}
+
+__attribute__((__weak__))
+void libos_dump_argv(int argc, const char* argv[])
+{
+}
+
+__attribute__((__weak__))
+void libos_dump_stack(const void* stack)
+{
+}
+
+__attribute__((__weak__))
+void libos_load_symbols(void)
+{
+}
+
+__attribute__((__weak__))
+long libos_add_symbol_file(const char* path, const void* text, size_t text_size)
+{
+    return -ENOTSUP;
+}
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index afec985a..9e2a2da5 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -27,6 +27,13 @@
 
 static void error(const char *, ...);
 
+void libos_trace(const char* msg);
+void libos_load_symbols(void);
+long libos_add_symbol_file(
+    const char* path,
+    const void* text,
+    size_t text_size);
+
 #define MAXP2(a,b) (-(-(a)&-(b)))
 #define ALIGN(x,y) ((x)+(y)-1 & -(y))
 
@@ -1098,6 +1105,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	map = noload ? 0 : map_library(fd, &temp_dso);
 	close(fd);
 	if (!map) return 0;
+	libos_add_symbol_file(pathname, temp_dso.map, temp_dso.map_len);
 
 	/* Avoid the danger of getting two versions of libc mapped into the
 	 * same process when an absolute pathname was used. The symbols
@@ -1797,6 +1805,7 @@ void __dls3(size_t *sp, size_t *auxv)
 			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
 			_exit(1);
 		}
+	        libos_add_symbol_file(argv[0], app.map, app.map_len);
 		close(fd);
 		ldso.name = ldname;
 		app.name = argv[0];
@@ -1936,6 +1945,7 @@ void __dls3(size_t *sp, size_t *auxv)
 	/* Determine if malloc was interposed by a replacement implementation
 	 * so that calloc and the memalign family can harden against the
 	 * possibility of incomplete replacement. */
+
 	if (find_sym(head, "malloc", 1).dso != &ldso)
 		__malloc_replaced = 1;
 
@@ -1955,7 +1965,11 @@ void __dls3(size_t *sp, size_t *auxv)
 
 	errno = 0;
 
+        libos_trace("entering program");
+        libos_load_symbols();
+
 	CRTJMP((void *)aux[AT_ENTRY], argv-1);
+
 	for(;;);
 }
 
@@ -2100,6 +2114,7 @@ end:
 		free(ctor_queue);
 	}
 	pthread_setcancelstate(cs, 0);
+        libos_load_symbols();
 	return p;
 }
 
diff --git a/src/misc/syscall.c b/src/misc/syscall.c
index 6f3ef656..009b29dd 100644
--- a/src/misc/syscall.c
+++ b/src/misc/syscall.c
@@ -2,6 +2,7 @@
 #include <unistd.h>
 #include "syscall.h"
 #include <stdarg.h>
+#include <errno.h>
 
 #undef syscall
 
@@ -19,3 +20,28 @@ long syscall(long n, ...)
 	va_end(ap);
 	return __syscall_ret(__syscall(n,a,b,c,d,e,f));
 }
+
+__attribute__((__weak__))
+long libos_syscall(long n, long params[6])
+{
+    (void)n;
+    (void)params;
+    return EINVAL;
+}
+
+long libos_syscall_variadic(long n, ...)
+{
+    va_list ap;
+    long params[6];
+
+    va_start(ap, n);
+    params[0] = va_arg(ap, long);
+    params[1] = va_arg(ap, long);
+    params[2] = va_arg(ap, long);
+    params[3] = va_arg(ap, long);
+    params[4] = va_arg(ap, long);
+    params[5] = va_arg(ap, long);
+    va_end(ap);
+
+    return libos_syscall(n, params);
+}
diff --git a/src/thread/clone.c b/src/thread/clone.c
index be80c8ea..afc8d160 100644
--- a/src/thread/clone.c
+++ b/src/thread/clone.c
@@ -1,6 +1,7 @@
 #include <errno.h>
 #include "pthread_impl.h"
 
+weak
 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 {
 	return -ENOSYS;
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
index 2f9d5e97..c2bf57d7 100644
--- a/src/thread/pthread_cancel.c
+++ b/src/thread/pthread_cancel.c
@@ -14,9 +14,7 @@ long __cancel()
 	return -ECANCELED;
 }
 
-long __syscall_cp_asm(volatile void *, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
+long __syscall_cp_asm(volatile void* cancel, long n, long params[6]);
 
 long __syscall_cp_c(syscall_arg_t nr,
                     syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
@@ -30,7 +28,8 @@ long __syscall_cp_c(syscall_arg_t nr,
 	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
 		return __syscall(nr, u, v, w, x, y, z);
 
-	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
+        long params[6] = { u, v, w, x, y, z };
+	r = __syscall_cp_asm(&self->cancel, nr, params);
 	if (r==-EINTR && nr!=SYS_close && self->cancel &&
 	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
 		r = __cancel();
diff --git a/src/thread/x86_64/syscall_cp.s b/src/thread/x86_64/syscall_cp.s
index 4f101716..78d207c6 100644
--- a/src/thread/x86_64/syscall_cp.s
+++ b/src/thread/x86_64/syscall_cp.s
@@ -9,22 +9,19 @@
 .global __syscall_cp_asm
 .hidden __syscall_cp_asm
 .type   __syscall_cp_asm,@function
+// __syscall_cp_asm(%rdi=cancel, %rsi=n, %rdx=params)
 __syscall_cp_asm:
 
 __cp_begin:
 	mov (%rdi),%eax
 	test %eax,%eax
 	jnz __cp_cancel
+
 	mov %rdi,%r11
-	mov %rsi,%rax
-	mov %rdx,%rdi
-	mov %rcx,%rsi
-	mov %r8,%rdx
-	mov %r9,%r10
-	mov 8(%rsp),%r8
-	mov 16(%rsp),%r9
+        mov %rsi, %rdi
+        mov %rdx, %rsi
 	mov %r11,8(%rsp)
-	syscall
+	jmp libos_syscall
 __cp_end:
 	ret
 __cp_cancel:
